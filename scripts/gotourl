#!/bin/bash

# Script to detect any URLs in a file. All URLs will be piped to dmenu to select. 
# The script will then try to detect a file format and open it in the program provided

OPEN_PIC=sxiv
OPEN_GIF=mpv
OPEN_PDF=zathura
OPEN_OTHER=$BROWSER


function failure {

	echo "Could not find file $1"
	echo "Exiting..."
	rm "/tmp/url" >& "/dev/null"
	rm "tmp/hist_tail" >& "/dev/null"
	exit 1
}

function parameters {
	
	# If only one argument was supplied and it was not an option, then it's assumed to be a file
	[ "$1" -eq 1 ] && [ "$2" != "-h" ] && [ "$2" != "-l" ] && [ "$2" != "-b" ] && SEARCH="$PWD/$2"

	# Check all arguments to find valid options
	for ARG in "$3"; do
		if [ "$ARG" = "-h" ]; then
			# Must redirect to /dev/tty, otherwise the text is returned as one big string
			echo "Usage: <gotourl> [options] file" > "/dev/tty"
			echo "-h: help menu" > "/dev/tty"
			echo "-b: bash history - Looks at the tail of your .bash_history for URLs" > "/dev/tty"
			echo "-l: point to the location of your .bash_history file" > "/dev/tty"
		fi
	done 

	# If -l is not supplied, assume bash_history is in default location
	HIST_LOCATION="$HOME/.bash_history" 

	# TODO: -l has not properly been implemented. Need to find a way to check the argument after -l option
	# if -l was supplied, use the provided history location
	for ARG in "$3"; do
		[ "$ARG" = "-l" ] && HIST_LOCATION=
	done

	# Refresh history and output last 10 lines to /tmp/hist_tail
	history -r > "/dev/null"
	tail $HIST_LOCATION > "/tmp/hist_tail"

	for ARG in "$3"; do
		[ "$ARG" = "-b" ] && SEARCH="/tmp/hist_tail"
	done

	# Hacky way to return local variable
	echo $SEARCH
}

### Script Begin ###

# If no arguments are supplied, request the name of the file, otherwise check parameters
[ "$#" -eq 0 ] && read -p "Please enter the file you'd like to parse " FILE && SEARCH="$PWD/$FILE" || SEARCH="$(parameters $# $1 $@)"
[ -z "$SEARCH" ] && exit 0
! [ -f "$SEARCH" ] && failure "$SEARCH"

# Test that there exists at least 1 valid URL
grep -q "https\?://\S*\.[A-Za-z]\+\S*" "$SEARCH" >& "/dev/null"
[ "$?" -ne 0 ] && echo "Could not find any valid URLs" && exit 0 

# Pipe to dmenu
URL="$(grep "https\?://\S*\.[A-Za-z]\+\S*" "$SEARCH" | dmenu -p "Select the URL you'd like to open" -l 10)"

# Assumes that only one extension will be found in URL
EXT=
! [ -z "$(echo $URL | grep "png")" ] && wget -q -O "/tmp/url" $URL && EXT=1
! [ -z "$(echo $URL | grep "jpe\?g")" ] && wget -q -O "/tmp/url" $URL && EXT=2
! [ -z "$(echo $URL | grep "gif")" ] && wget -q -O "/tmp/url" $URL && EXT=3
! [ -z "$(echo $URL | grep "pdf")" ] && wget -q -O "/tmp/url" $URL && EXT=4

# Ensure that wget downloaded the file, otherwise throw exception
! [ -f "/tmp/url" ] && ! [ -z "$EXT" ] && failure "/tmp/url"

# Note: The use of $TERMINAL env var with -e option was not tested for terms other than st
case $EXT in
	1)
		$TERMINAL -e $OPEN_PIC "/tmp/url"
		;;
	2)
		$TERMINAL -e $OPEN_PIC "/tmp/url"
		;;
	3)
		$TERMINAL -e $OPEN_GIF --loop-file=inf "/tmp/url"
		;;
	4)
		$TERMINAL -e $OPEN_PDF "/tmp/url"
		;;
	*)
		$TERMINAL -e $OPEN_OTHER $URL
		;;
esac

rm "/tmp/hist_tail" >& "/dev/null"
rm "/tmp/url" >& "/dev/null"

exit 0
